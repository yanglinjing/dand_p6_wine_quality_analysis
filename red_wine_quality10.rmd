# Red Wine Quality Analysis
### Which chemical properties influence the quality of red wines?

By Linjing Yang

# Introduction
The tidy data set contains 1,599 red wines [^1] with 11 variables on the chemical properties of the wine. At least 3 wine experts rated the quality of each wine, providing a rating between 0 (very bad) and 10 (very excellent).

+ 1599 records
+ 11 chemical properties
+ quality rating: 0 - 10

## Variables

###Input variables (based on physicochemical tests):
1. fixed acidity (tartaric acid - g / dm^3)
2. volatile acidity (acetic acid - g / dm^3)
3. citric acid (g / dm^3)
4. residual sugar (g / dm^3)
5. chlorides (sodium chloride - g / dm^3
6. free sulfur dioxide (mg / dm^3)
7. total sulfur dioxide (mg / dm^3)
8. density (g / cm^3)
9. pH
10. sulphates (potassium sulphate - g / dm3)
11. alcohol (% by volume)
   
###Output variable (based on sensory data): 
12. quality (score between 0 and 10)





# Exploration of Data
```{r echo=FALSE}
# {r echo=FALSE} Do not show this code block.

# Avoid all codes and warnings to be shown in the HTML document
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```

```{r}
### Load libraries
library(GGally)
library(ggplot2)
library(gridExtra)
library(RColorBrewer) # Scatter Plot: color
library(dplyr) # %>%
library(tidyr)
library(memisc) # Linear Regression: mtable
library(corrplot) # correlation matrix
library(ggridges) # Ridge Line Plot
library(kableExtra) # Show the head of the orginal data
library(tibble) # Check distribution of the whole group of chemicals
library(car) # Scatterplot Matrix
library(corrplot) # Correlation Matrix (with cor. number)

library(ellipse)
library(RColorBrewer)
library(ggpubr) # add cor coefficient to scatter plot
```

```{r results = 'hide'}
#{r results = 'hide'} Do not show the result of this code block.

### Load the data
getwd()
list.files()
df <- read.csv('wineQualityReds.csv')
head(df)
```

```{r results = 'hide'}
# Details of data
str(df)
```

```{r}
# show the head of the data

# Subset: drop 1st line - X
# tmpdata <- subset(df, select = -c(varname))
df_s <- subset(df, select = -c(X))

# Draw the table
df_s %>% head(6) %>% kable() %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    full_width = F
  )
```

```{r}
# All chemicals in df
chemicals <-  list(
                df$alcohol,
                df$citric.acid,
                df$chlorides,
                df$density,
                df$fixed.acidity, 
                df$free.sulfur.dioxide, 
                df$pH,
                df$residual.sugar,
                df$sulphates,
                df$volatile.acidity,
                df$total.sulfur.dioxide
                  )

# List:
#   Index of lists starts from [1] rather than [0]
#   Access the element of a list: list[[index]]

```

```{r}
# Names of all chemicals
chemical_names <- c(
    'Alcohol',
    'Citric Acid',
    'Chlorides',
    'Density',
    'Fixed Acidity', 
    'Free Sulfur Dioxide', 
    'pH Value',
    'Residual Sugar',
    'Sulphates',
    'Volatile Acidity',
    'Total Sulfur Dioxide'
)
```

```{r}
# Plot arguments of chemicals

# c(start, end, step)

chemical_units <- list(
                      #alcohol  1
                      '(% by volume)',
                      
                      #citric.acid 2
                      '(g / dm^3)',
                      
                      #chlorides 3
                      '(g / dm^3)',
                      
                      #density 4
                      '(g / cm^3)',
                      
                      #fixed.acidity 5
                      '(g / dm^3)', 
                      
                      #free.sulfur.dioxide 6 
                      '(mg / dm^3)', 
                      
                      #pH 7
                      '', 
                      
                      #residual.sugar 8 
                      '(g / dm^3)', 
                      
                      #sulphates 9
                      '(g / dm3)',
                      
                      #volatile.acidity 10
                      '(g / dm^3)', 
                      
                      #total.sulfur.dioxide 11
                      '(mg / dm^3)' 
                    )
```

```{r}
# Plot arguments of chemicals

# c(start, end, step)

chemical_args <- list(
                      #alcohol  1
                      c(8, 15, 1),
                      
                      #citric.acid 2
                      c(0, 1, 0.1),
                      
                      #chlorides 3
                      c(0, 0.2, 0.02),
                      
                      #density 4
                      c(0.99, 1.0037, 0.01),
                      
                      #fixed.acidity 5
                      c(4, 16, 1), 
                      
                      #free.sulfur.dioxide 6 
                      c(1, 72, 10), 
                      
                      #pH 7
                      c(2.7, 4.1, 0.5), 
                      
                      #residual.sugar 8 
                      c(1, 5, 0.5), 
                      
                      #sulphates 9
                      c(0.3, 1.3, 0.2),
                      
                      #volatile.acidity 10
                      c(0.1, 1.2, 0.2), 
                      
                      #total.sulfur.dioxide 11
                      c(6, 160, 50) 
                    )
```

```{r}
# Function: Density plot

create_density <- 
  function(chemical, chemical_name, start, end, step, chemical_unit){
    p <- ggplot(aes(x=chemical), 
                data =df) +
         geom_density(alpha = my_alpha, fill= my_color, color = my_color) +
         scale_x_continuous(limits = c(start, end),
                            breaks = seq(start, end, step))+
         labs(
           x = paste(chemical_name, chemical_unit),
           y = 'Density')
    return(p)
  }
```

```{r}
# Function: create 3 histograms: orginal, log10, sqrt
# And put density plot together

create_4_plots_table <- 
  function(chemical, chemical_name, start, end, step, chemical_unit){
    p1 <- ggplot(aes(x=chemical), data= df) +
            geom_histogram(alpha = my_alpha, fill= my_color) +
            xlab(paste(chemical_name, chemical_unit, sep = ' '))
    
    p2 <- p1 + scale_x_log10() + 
               xlab(paste(chemical_name, "(log10)", sep = ' '))
    
    p3 <- p1 + scale_x_sqrt() + 
               xlab(paste(chemical_name, "(sqrt)", sep = ' '))
  
    p0 <- create_density(chemical, chemical_name, 
                         start, end, step, chemical_unit)
    
    p <- grid.arrange(p0, p1, p2, p3, 
                      ncol=2, 
                      top = chemical_name # Name of the four plots
                      ) 
    return(p)
  }
```

```{r}
# set color arguments

my_color <- '#008AD8'   # Main Color of this report: blue

# "#BB4444", "#EE9988" ,'#f9e0db', '#008AD8', #68c6f9,'#cfeaf9'
red <- c("#BB4444", "#EE9988" ,'#f9e0db')

blue <- c('#0167a3','#008AD8', '#68c6f9','#92cdef','#cfeaf9')

my_alpha <- 0.7
```

```{r}
# Set themes

my_theme <- theme(
                plot.title = element_text(size = 20),  
                axis.title.x = element_text(size = 14),  
                axis.title.y = element_text(size = 14),
                
                legend.title = element_text(size = 14),
                legend.text = element_text(size = 12),
                axis.text.x = element_text(angle = 90, hjust = 1) #Rotate axis labels
             )
```


```{r}
# Scatter plot: Lines
line_mean <- geom_line(stat='summary', fun.y=mean, 
                       linetype=1, color='red')

line_median <- geom_line(stat='summary', fun.y=quantile,
                         fun.args=list(probs=.5),
                         linetype=1, color=my_color)
```

```{r}
# Scatter plot: Regression Line
line_regression <- geom_smooth(method='lm',formula=y~x, 
                               color=my_color, fill = "skyblue"
                               )
```


```{r}
# scatter plot:  Add correlation coefficient (r)

# library(ggpubr)
text_cor <- stat_cor(method = "spearman")
```


```{r}
# Scatter Plot: Quality v.s. Chemical

# Draw Plot
create_scatter <- 
  function(chemical, chemical_name, start, end, step, chemical_unit){
    p <- ggplot(aes(x=chemical, y=quality),data=df)+
          geom_point(alpha = 0.1, size = 1, 
                     position = 'jitter', color=my_color) +
          scale_x_continuous(limits = c(start, end),
                            breaks = seq(start, end, step)) +
          labs(
              title = paste(chemical_name, 'and Quality'),
              x = paste(chemical_name, chemical_unit),
              y = "Quality"
           ) +
          line_regression +
          line_mean +
          text_cor
    return(p)
  }
```



```{r}
#test

#create_scatter(df$alcohol, 'Alcohol', 8, 15, 1, 'mg' )
```



```{r results = 'hide'}
#Ridge Line Plot

# Step 1: group df by quality

df$quality.group <-
  cut(df$quality,
      c(3,4,5,6,8))

table(df$quality.group,
      useNA = 'ifany')
```

```{r}
#Ridge Line Plot

# Step 2: subset: df without quality=NA

df_quality <- subset(df, !is.na(quality.group))

chemicals_group_by_qty <- list(
                                df_quality$alcohol,
                                df_quality$citric.acid,
                                df_quality$chlorides,
                                df_quality$density,
                                df_quality$fixed.acidity, 
                                df_quality$free.sulfur.dioxide, 
                                df_quality$pH,
                                df_quality$residual.sugar,
                                df_quality$sulphates,
                                df_quality$volatile.acidity,
                                df_quality$total.sulfur.dioxide
                             )

```

```{r}
#Ridge Line Plot

# Step 3: Function: Ridge Line Plot

create_ridgeline <- function(chemical, chemical_name, start, end, step){
  p <- ggplot(aes(x = chemical, y = quality.group, fill = quality.group), 
              data= df_quality) +
         geom_density_ridges(scale = 0.8, size = 0.25, rel_min_height = 0.03) +
         scale_x_continuous(limits = c(start, end),
                            breaks = seq(start, end, step))+
         theme_ridges() + 
         theme(legend.position = "none")+
         labs(
            x = chemical_name,
            y = "Quality"
         ) +
         my_theme
              
  return(p)
}
```


```{r}
#Violin Plot: Step 1

# Function to produce summary statistics (mean and +/- sd)

data_summary <- function(x) {
   m <- mean(x)
   ymin <- m-sd(x)
   ymax <- m+sd(x)
   return(c(y = m, ymin = ymin, ymax = ymax))
}

### Source: http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization
```

```{r}
#Violin Plot: Step 2

# Function: draw plot (chemicals vs quality.group)

create_violin <- function(chemical, chemical_name, start, end, step){
  p <-  ggplot(df_quality, 
               aes(x = quality.group, 
                   y = chemical, 
                   fill = quality.group)) + 
          geom_violin() + 
          scale_y_continuous(limits = c(start, end),
                                breaks = seq(start, end, step))+
          stat_summary(fun.data=data_summary)+ 
          coord_flip() + #flip x and y
          labs(
                  y = chemical_name,
                  x = "Quality"
          )+
          my_theme
            
  return(p)
}

# Because I flipped x and y,
# scale_y_continuous was used, and x- / y- labs were exchanged.

```


```{r results='hide'}
# Scatter Plot: 3 variables -- Two chemicals + Quality (group by alcohol)

# Step 1: group df by alcohol

# add a new variable for grouping
df$alcohol.group <-
  cut(df$alcohol, c(8.4,9.2,9.5,10,10.5,11,12,14.9))

# check the new variable
table(df$alcohol.group, useNA = 'ifany')

```

```{r}
# Step 2: build new subset without NA of alcohol

df_alcohol <- subset(df, !is.na(alcohol.group))
```

```{r}
# Step 3: Draw Plot

create_scatter_3var <- function(c1, c1_name, c1_unit, # c1 - Chemical at x-axis
                                start, end, step, 
                                c2, c2_name, c2_unit  # c2 - Chemical put into group
                                ) {
  p <- ggplot(aes(x = c1, y = quality, color = c2), data = df_alcohol) +
    
          geom_point(alpha = 0.5, size = 1, position = 'jitter') + 
    
          scale_color_brewer(type = 'div',
                       guide = guide_legend(title = paste(c2_name,'\n', c2_unit), 
                                            reverse = TRUE,
                                            override.aes = list(alpha = 1, size = 2)))+
    
          scale_x_continuous(
                             limits = c(start, end),
                             breaks = seq(start, end, step)
                             )+
          line_regression +
    
          labs(
                title = paste('Quality v.s.\n', c1_name, '&', c2_name),
                x = paste(c1_name, c1_unit),
                y = "Quality"
          ) +
    
          my_theme # theme()

  return(p)
  
}
```

```{r}
# Bivarite Plots: scatter + ridgeline + violine plots

draw_3_bivarite_plots <- function(c1, c2, c_name, start, end, step, unit){
  #c1 <- chemical
  #c2 <- chemicals_group_by_qty
  
  # step 1: draw plots
  p1 <- create_scatter(c1, c_name, start, end, step, unit)
  p2 <- create_ridgeline(c2, c_name, start, end, step)
  p3 <- create_violin(c2, c_name, start, end, step)
  
  # step 2: print plots
  print(p1)
  grid.arrange(p2, p3, nrow = 1)
}
```


```{r}
# The doughnut function permits to draw a donut plot
create_doughnut <-
function (x, labels = names(x), 
          edges = 200, 
          outer.radius = 0.8, 
          inner.radius=0.6, # inner.radius controls the width of the ring!
          clockwise = FALSE,
          init.angle = if (clockwise) 90 else 0, density = NULL, 
          angle = 45, col = NULL, border = FALSE, lty = NULL, 
          main = NULL, ...)
{
    if (!is.numeric(x) || any(is.na(x) | x < 0))
        stop("'x' values must be positive.")
    if (is.null(labels))
        labels <- as.character(seq_along(x))
    else labels <- as.graphicsAnnot(labels)
    x <- c(0, cumsum(x)/sum(x))
    dx <- diff(x)
    nx <- length(dx)
    plot.new()
    pin <- par("pin")
    xlim <- ylim <- c(-1, 1)
    if (pin[1L] > pin[2L])
        xlim <- (pin[1L]/pin[2L]) * xlim
    else ylim <- (pin[2L]/pin[1L]) * ylim
    plot.window(xlim, ylim, "", asp = 1)
    if (is.null(col))
        col <- if (is.null(density))
          palette()
        else par("fg")
    col <- rep(col, length.out = nx)
    border <- rep(border, length.out = nx)
    lty <- rep(lty, length.out = nx)
    angle <- rep(angle, length.out = nx)
    density <- rep(density, length.out = nx)
    twopi <- if (clockwise)
        -2 * pi
    else 2 * pi
    t2xy <- function(t, radius) {
        t2p <- twopi * t + init.angle * pi/180
        list(x = radius * cos(t2p), 
             y = radius * sin(t2p))
    }
    for (i in 1L:nx) {
        n <- max(2, floor(edges * dx[i]))
        P <- t2xy(seq.int(x[i], x[i + 1], length.out = n),
                  outer.radius)
        polygon(c(P$x, 0), c(P$y, 0), density = density[i], 
                angle = angle[i], border = border[i], 
                col = col[i], lty = lty[i])
        Pout <- t2xy(mean(x[i + 0:1]), outer.radius)
        
        # labels
        lab <- as.character(labels[i])
        
        if (!is.na(lab) && nzchar(lab)) {
            lines(c(1, 1.05) * Pout$x, c(1, 1.05) * Pout$y)
            text(1.1 * Pout$x, 1.1 * Pout$y, labels[i], 
                 xpd = TRUE, adj = ifelse(Pout$x < 0, 1, 0), 
                 ...)
        }
        ## Add white disc          
        Pin <- t2xy(seq.int(0, 1, length.out = n*nx),
                  inner.radius)
        polygon(Pin$x, Pin$y, density = density[i], 
                angle = angle[i], border = border[i], 
                col = "white", lty = lty[i])
    }
 
    title(main = main, ...)
    invisible(NULL)
}


# source: https://www.r-graph-gallery.com/130-ring-or-donut-chart/
 
# Let's use the function, it works like PiePlot !
# inner.radius controls the width of the ring!

# test
# create_doughnut(qlt_count, inner.radius=0.5,labels = qlt_category,col=qlt_color)

```


```{r}
text_bivar <- list(
  #alcohol  1
  'Alcohol and Quality are positively correlated.',
  
  #citric.acid 2
  'Citric Acid and Quality are not correlated.',
  
  #chlorides 3
  'Chlorides and Quality are not correlated.',
  
  #density 4
  'Density and Quality are not correlated.',
  
  #fixed.acidity 5
  'Fixed Acidity and Quality are not correlated.', 
  
  #free.sulfur.dioxide 6 
  'Free Sulfur Dioxide and Quality are not correlated.', 
  
  #pH 7
  'PH values and Quality are not correlated.', 
  
  #residual.sugar 8 
  'Residual Sugar and Quality are not correlated.', 
                      
  #sulphates 9
  'Sulphates and Quality are positively correlated.',
  
  #volatile.acidity 10
  'Volatile Acidity and Quality are negatively correlated.', 
  
  #total.sulfur.dioxide 11
  'Free Sulfur Dioxide and Quality are not correlated.'
)
```

```{r}
text_univar <- list(
  #alcohol  1
  'Alcohol is right skewed.',
  
  #citric.acid 2
  'Citric Acid is right skewed.',
  
  #chlorides 3
  'Chlorides is right skewed.\nLog10 seems to be a better method to nomalise it.',
  
  #density 4
  'Density is normaly distributed.',
  
  #fixed.acidity 5
  'Fixed Acidity is right skewed.\nLog10 seems to be a better method to nomalise it.', 
  
  #free.sulfur.dioxide 6 
  'Free Sulfur Dioxideis right skewed.\nSqrt seems to be a better method to nomalise it.', 
  
  #pH 7
  'PH values is normaly distributed.', 
  
  #residual.sugar 8 
  'Residual Sugar is right skewed.', 
                      
  #sulphates 9
  'Sulphates is right skewed.\nLog10 seems to be a better method to nomalise it.',
  
  #volatile.acidity 10
  'Volatile is right skewed.\nSqrt seems to be a better method to nomalise it.', 
  
  #total.sulfur.dioxide 11
  'Free Sulfur Dioxide is right skewed.\nLog10 seems to be a better method to nomalise it.'
)
```



## Univariate

### Histogram of All the Variables
```{r}
# Show the histogram of all variables

# Draw histograms
df_s %>%  # Drop 1st column 
  as.tibble() %>%
  gather(variable, value) %>%
  ggplot( aes(x=value) ) +
    geom_histogram(alpha = my_alpha, fill= my_color) +
    facet_wrap(~variable, scale="free")
```

### Quality (Rating 0 - 10)

```{r}
summary(df$quality)
```

```{r results = 'hide'}
table(df$quality)
```

```{r}
# Ordinal Variable: use 'geom_bar()' instead of 'geom_histogram()'

ggplot(df, aes(x=factor(quality))) + 
  geom_bar(alpha = my_alpha, fill= my_color) +
  labs(
    x = 'Quality Ratings',
    y = 'Count'
  )
  
```


```{r}
# Donut Plot args

qlt_category <- c(3, 4, 5, 6, 7, 8) #6 categories

qlt_count <- c(10, 53, 681, 638, 199, 18)

qlt_color <- c(blue[[5]], red[[2]], blue[[1]], blue[[2]], blue[[3]], red[[1]]) #6 colors

```


```{r}
# Draw donut plot

create_doughnut(qlt_count, 
              inner.radius=0.5, # inner.radius controls the width of the ring!
              labels = qlt_category,
              col=qlt_color )
```

### Chemicals
```{r}
# Draw Univariate Plots (group of 4)
for (i in 1:11) {

  # print the 4 plots
  p <- create_4_plots_table(
                            chemicals[[i]],
                            chemical_names[[i]],
                            chemical_args[[i]][[1]],
                            chemical_args[[i]][[2]],
                            chemical_args[[i]][[3]],
                            chemical_units[[i]]
                          )
  
  #print(p) -- ggplot requires 'print(p)' as it is in this loop function, but no need 'print(p)' with arrange.grib. Otherwise the output includes the gtable.
  
  # summary of the variable
  s <- summary(chemicals[[i]])
  
  # print markdown title: cat()
  cat(paste(chemical_names[[i]], '\n\n\n'))
  print(s)
  cat('\n\n')
  cat(text_univar[[i]])
}
```




## Bivariate - Quality vs Chemicals

### Plots: Quality vs Chemicals
```{r}
# 3 kinds of plot to explore 
# the relationship between a chemical and the quality

for (i in 1:11){
  
  # step 1: get arguments
  c1 <- chemicals[[i]]
  c2 <- chemicals_group_by_qty[[i]]
  
  c_name <- chemical_names[[i]]
  
  unit <- chemical_units[[i]]
  
  start <- chemical_args[[i]][[1]]
  end <- chemical_args[[i]][[2]]
  step <- chemical_args[[i]][[3]]
  
  # step 2: draw plots
  draw_3_bivarite_plots(c1, c2, c_name, start, end, step, unit)
  
  # step 3: add analysis
  cat(text_bivar[[i]])
}
```

From the plots above, we can find that there are 3 chemicals correlated with quality:

+ Volatile Acidity: negative
+ Sulphates: positive
+ Alcohol: positive

### Spearman Correlation Coefficience: Quality vs Chemicals
```{r}
# Spearman Correlation: Quality vs Chemicals

# Build a new data frame to store r
cor_quality <- data.frame(matrix(nrow = 11, ncol = 2))

# Name 2 columns of table
colnames(cor_quality) <- c("chemicals", "r")

# Put r into the new data frame
for (i in 1:11) {
 cor <- cor(chemicals[[i]], df$quality, method = "spearman")
 cor_quality [i, 1] <- chemical_names[i]
 cor_quality [i, 2] <- cor
}
```

```{r}
# Show r in table

# Ordered by absolute value of r
cor_table <- arrange(cor_quality, desc(abs(r)))

# Print in table format
cor_table %>% kable() %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    full_width = F
  )

```

```{r}
# Plot of r

# Reorder
cor_quality %>%
  arrange(abs(r)) %>%
  #mutate(new_var = existing_var)
  mutate(c = factor(chemicals, chemicals)) %>%
  ggplot(aes(x = c, y = r)) +
    geom_segment( aes(x = c, xend=c, y=0, yend=r), 
                  color="skyblue", 
                  size=1) +
    geom_point( color="blue", size=4, alpha=0.6) +
    theme_light() +
    coord_flip() +
    theme(
      panel.grid.major.y = element_blank(),
      panel.border = element_blank(),
      axis.ticks.y = element_blank()
    ) +
  xlab("") +
  ylab("Spearman Correlation Coefficience with Quality")
```

+ Alcohol, Volatile Acidity and Sulphates are moderately correlated with quality.

+ Other chemicals are not correlated with quality.



## Bivariate - Chemicals

```{r results = 'hide'}

# Compute 'Pearson' correlation between chemicals

df_no_quality <- df[, (2:12)]
r <- cor(df_no_quality)
head(round(r,2))
```

### Correlation Matrix
```{r}
# Build a Pannel of 100 colors with Rcolor Brewer
r_colors <- brewer.pal(5, "RdBu")
r_colors=colorRampPalette(r_colors)(100)
 
# Order the correlation matrix
ord <- order(r[1, ])
r_ord = r[ord, ord]
plotcorr(r_ord , col=r_colors[r_ord*50+50] , mar=c(1,1,1,1)  )
```

From the correlation matrix, it could be seen that there some chemicals are highly correlated with others:

+ pH v.s Fixed Acidity
+ pH v.s. Citric Aciity
+ Citric Acid v.s. Fixed Acidity
+ Citric Acidity v.s. Volatile Acidity
+ Density v.s. Fixed Acidity
+ Free Sulfur Dioxide v.s. Total Sulfur Dioxide

Besides, the three chemicals that are moderately correlated with quality - Alcohol, Volatile Acidity and Sulphates, are not correlate with each other.

The correlation coefficient could be found in the following table.

### Pearson Correlation Coefficient between Chemicals
```{r results='hide'}
#To compute the matrix of p-value, a custom R function is used :

# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(df_no_quality)
head(p.mat[, 1:5])

### Source: http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram
```

```{r}
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

corrplot(r, method="color", col=col(1000),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=20, # Text label color and rotation
         p.mat = p.mat, sig.level = 0.05, insig = "blank", # Combine with significance
         diag=FALSE,  # hide correlation coefficient on the principal diagonal
         number.cex=0.75, # change font size of r
         tl.cex = 0.8 # change font size of labels
         )

### source: http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram
```

Pearson Correlation Coefficient of Highly Correlated Chemicals:

+ pH v.s Fixed Acidity: -0.68
+ pH v.s. Citric Aciity: -0.54
+ Citric Acid v.s. Fixed Acidity: 0.67
+ Citric Acid v.s. Volatile Acidity: -0.55
+ Density v.s. Fixed Acidity: 0.67
+ Free Sulfur Dioxide v.s. Total Sulfur Dioxide:  0.67

The relationship between these chemicals are shown as follows.

### Moderately / Highly Correlated Chemicals
```{r}
# plot the chemicals with r>0.5
scatterplotMatrix(~citric.acid +
                    density +
                    fixed.acidity + 
                    free.sulfur.dioxide + 
                    pH +
                    total.sulfur.dioxide, 
                  data = df ,
                  reg.line = FALSE,
                  col = my_color , 
                  pch = 20,
                  cex =1.5,
                  main = "Scatter Plot of Correlated Chemicals" )

```

## Multivariate - Chemicals

### PH, Fixed Acidity & Density
From the correlation matrix, it is shown that PH, Fixed Acidity & Density are highly correlated with each other. Thus, the following plot is draw to present the relationship between them.

```{r results='hide'}
## Step 1: group df by fixed.acidity

# add a new variable for grouping
df$fixed.acidity.group <-
  cut(df$fixed.acidity, c(4.60, 7.10, 7.90, 9.20, 15.90))

# check the new variable
table(df$fixed.acidity.group, useNA = 'ifany')
```

```{r}
# Step 2: build new subset without NA of fixed.acidity

df_fixed.acidity <- subset(df, !is.na(fixed.acidity.group))
```

```{r}
# Step 3: draw plot - PH, Fixed Acidity & Density
p_3 <- ggplot(aes(x = citric.acid, y = pH, color = fixed.acidity.group),
              data = df_fixed.acidity )+
        geom_point(alpha = 0.5, size = 1, position = 'jitter')+
        scale_color_brewer(type = 'div',
                           guide = guide_legend(title = "Fixed Acidity\n (g / dm^3)", 
                                                reverse = TRUE,
                                                override.aes = list(alpha = 1, size = 2)))+
        scale_x_continuous()+
        ggtitle('PH Values v.s.\n Citric Acid & Fixed Acidity')+ 
        xlab("Citric Acid (g / cm^3)") + 
        ylab("PH Value")+
        my_theme +
        line_regression

print(p_3)
```

From the plot, we can easily see the trends:

+ Citric Acid and pH values are negatively correlated.

+ Fixed acidity and pH values are negatively correlated.

+ Fixed acidity and Citric Acid are positively correlated.




## Multivariate - Quality v.s. Chemicals

3 chemicals are correlated with quality:

+ Volatile Acidity: negative
+ Sulphates: positive
+ Alcohol: positive

From the correlation matrix above, it can be found that these 3 chemicals are not correlated with each other. Thus, they independently affect quality scores.

### Quality, Alcohol and Volatile Acidity
```{r}
# Draw Scatter Plot: volatile.acidity & alcohol & quality
p_1 <- create_scatter_3var(df_alcohol$volatile.acidity, 'Volatile Acidity', 
                    chemical_units[[10]],
                    chemical_args[[10]][[1]],
                    chemical_args[[10]][[2]],
                    chemical_args[[10]][[3]],
                    df_alcohol$alcohol.group, 'Alcohol',
                    chemical_units[[1]])
print(p_1) # p_1 will be used in "Final Plots" Section
```

+ Alcohol and quality are positively correlated.

+ Volatile acidity and quality are negatively correlated.

### Quality, Alcohol and Sulphates
```{r}
# Draw Scatter Plot: sulphates & alcohol & quality
p_2 <- create_scatter_3var(df_alcohol$sulphates, 'Sulphates', 
                    chemical_units[[9]],
                    chemical_args[[9]][[1]],
                    chemical_args[[9]][[2]],
                    chemical_args[[9]][[3]],
                    df_alcohol$alcohol.group, 'Alcohol',
                    chemical_units[[1]]
                    )
print(p_2) # p_2 will be used in "Final Plots" Section
```

+ Alcohol and quality are positively correlated.

+ Sulphates and quality are positively correlated.



# Final Plots and Summary

## Quality, Alcohol and Volatile Acidity
```{r}
# Draw Scatter Plot: volatile.acidity & alcohol & quality
print(p_1)
```

+ Alcohol and quality are positively correlated.

+ Volatile acidity and quality are negatively correlated.


## Quality, Alcohol and Sulphates
```{r}
# Draw Scatter Plot: sulphates & alcohol & quality
print(p_2)
```

+ Alcohol and quality are positively correlated.

+ Sulphates and quality are positively correlated.


## PH Values, Density and Fixed Acidity
```{r}
# Scatter plot: PH, Fixed Acidity & Density
print(p_3)
```

+ Density and pH values are negatively correlated.

+ Fixed acidity and pH values are negatively correlated.

+ Fixed acidity and density values are positively correlated.


# Reflection

## Conclusion
3 out of 11 chemicals are moderately correlated with quality:

+ Volatile Acidity (negatively),
+ Sulphates (positively) and
+ Alcohol (positively),

while others are not correlated.

Besides, these 3 chemicals are not correlated with each other. Thus, they can be used to predict the quality score.

## Limitation

There are some chemicals highly correlated with each other:

+ pH and Fixed Acidity
+ pH and. Citric Aciity
+ Citric Acid and Fixed Acidity
+ Citric Acidity and Volatile Acidity
+ Density and Fixed Acidity
+ Free Sulfur Dioxide and Total Sulfur Dioxide

To design a better experiment, it would be helpful to drop some of the highly correlated variables.


Besides, the quality scores are mainly between 5-6, and some are 7. It can be noticed that none of the wines were scored 0-2 and 9-10. Usually a 5-point scale would be better for scoring. 

It might also be helpful to ask experts to score the acidity and sweetness after tasting (e.g 1-Not sweet at all ~ 5-Too sweet). Then we can compare the degree of real sweetness /sourness and the subjective feeling of it.

## Success and Improvement

I feel it is much more clear to separate the data and the plot function. The code structure is better after gathering data and put it into array-like storage.

I would try more kinds of plots and to add more details for the plots the next time (e.g. I tried to add a layer to show correlation coefficiency on the scatter plot, but I failed.)


[^1]: Information of the Original Data:
 P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. 
 Modeling wine preferences by data mining from physicochemical properties.
 In Decision Support Systems, Elsevier, 47(4):547-553. ISSN: 0167-9236.
